---
- name: Collect private IPs
  run_once: yes
  block:
    - ansible.builtin.set_fact:
        private_ips: "{{
          private_ips|default([])
          + [
            hostvars[item].ansible_default_ipv4.address | ansible.utils.ipaddr('private')
          ]
        }}"
      loop: "{{ ansible_play_hosts_all }}"
    - ansible.builtin.set_fact:
        neighbor_ips: "{{
          private_ips
          |difference(ansible_default_ipv4.address | ansible.utils.ipaddr('private'))
          |join(',')
        }}"

- debug:
    msg: "{{ hostvars[inventory_hostname]['ansible_' + iptables_wireguard_interface].ipv4.address | ansible.utils.ipsubnet }}"

- name: Install iptables-persistent
  ansible.builtin.apt:
    update_cache: yes
    package:
      - iptables-persistent
    install_recommends: no

- name: Enable iptables service
  ansible.builtin.systemd:
    enabled: yes
    name: iptables
    state: started

- name: Reset iptables
  block:
    - name: ACCEPT INPUT chain
      ansible.builtin.iptables:
        chain_management: yes
        chain: INPUT
        policy: ACCEPT

    - name: Flush rules
      ansible.builtin.iptables:
        flush: yes
        table: "{{ item }}"
      loop:
        - filter
        - nat
        - mangle
        - raw
        - security

    - name: Delete chains
      ansible.builtin.command:
        cmd: "iptables -t {{ item }} -X"
      loop:
        - filter
        - nat
        - mangle
        - raw
        - security

    - name: Accept INPUT chain
      ansible.builtin.iptables:
        chain_management: yes
        chain: INPUT
        policy: ACCEPT

    - name: Accept FORWARD chain
      ansible.builtin.iptables:
        chain_management: yes
        chain: FORWARD
        policy: ACCEPT

    - name: Accept OUTPUT chain
      ansible.builtin.iptables:
        chain_management: yes
        chain: OUTPUT
        policy: ACCEPT
  when: iptables_reset_all

- name: Create TCP chain
#  ansible.builtin.command:
#    cmd: "iptables -N TCP"
  ansible.builtin.iptables:
    chain: TCP
    chain_management: yes
    state: present

- name: Create UDP chain
#  ansible.builtin.command:
#    cmd: "iptables -N UDP"
  ansible.builtin.iptables:
    chain: UDP
    chain_management: yes
    state: present

- name: Forwarding all wireguard traffic
  ansible.builtin.iptables:
    chain: FORWARD
    in_interface: "{{ iptables_wireguard_interface }}"
    out_interface: "{{ iptables_wireguard_interface }}"
    jump: ACCEPT
  when: iptables_wireguard_is_site

- name: Drop FORWARD chain
  ansible.builtin.iptables:
    chain_management: yes
    chain: FORWARD
    policy: DROP

- name: Accept OUTPUT chain
  ansible.builtin.iptables:
    chain_management: yes
    chain: OUTPUT
    policy: ACCEPT

- name: Allow established connections, or new valid traffic
  ansible.builtin.iptables:
    chain: INPUT
    ctstate:
      - RELATED
      - ESTABLISHED
    jump: ACCEPT

- name: Allow all from loopback
  ansible.builtin.iptables:
    chain: INPUT
    in_interface: lo
    jump: ACCEPT

- name: Drop all traffic with an "INVALID" state
  ansible.builtin.iptables:
    chain: INPUT
    ctstate:
      - INVALID
    jump: DROP

- name: Allow all new incoming ICMP echo requests
  ansible.builtin.iptables:
    chain: INPUT
    protocol: icmp
    icmp_type: 8
    ctstate:
      - NEW
    jump: ACCEPT

- name: Attach the UDP chain to the INPUT chain
  ansible.builtin.iptables:
    chain: INPUT
    protocol: udp
    ctstate:
      - NEW
    jump: UDP

- name: Attach the TCP chain to the INPUT chain
  ansible.builtin.iptables:
    chain: INPUT
    protocol: tcp
    syn: match
    ctstate:
      - NEW
    jump: TCP

- name: Reject UDP streams with ICMP port unreachable messages [UDP scans]
  block:
    - name: Remove existing rule if exists
      ansible.builtin.command:
        cmd: "iptables -D INPUT -p udp -m recent --set --rsource --name UDP-PORTSCAN -j REJECT --reject-with icmp-port-unreachable"
      ignore_errors: yes
    - name: Create rule
      ansible.builtin.command:
        cmd: "iptables -A INPUT -p udp -m recent --set --rsource --name UDP-PORTSCAN -j REJECT --reject-with icmp-port-unreachable"
  when: iptables_tricking_port_scanners

- name: Reject UDP streams with ICMP port unreachable messages
  ansible.builtin.iptables:
    chain: INPUT
    protocol: udp
    reject_with: icmp-port-unreachable
  when: not iptables_tricking_port_scanners

- name: Reject TCP connections with TCP RESET packets [SYN scans]
  block:
    - name: Remove existing rule if exists
      ansible.builtin.command:
        cmd: "iptables -D INPUT -p tcp -m recent --set --rsource --name TCP-PORTSCAN -j REJECT --reject-with tcp-reset"
      ignore_errors: yes
    - name: Create rule
      ansible.builtin.command:
        cmd: "iptables -A INPUT -p tcp -m recent --set --rsource --name TCP-PORTSCAN -j REJECT --reject-with tcp-reset"
  when: iptables_tricking_port_scanners

- name: Reject TCP Connection with TCP RESET packets
  ansible.builtin.iptables:
    chain: INPUT
    protocol: tcp
    reject_with: tcp-reset
  when: not iptables_tricking_port_scanners

- name: Reject all remaining incoming traffic with icmp protocol unreachable messages [port scan]
  block:
    - name: Remove existing rule if exists
      ansible.builtin.iptables:
        chain: INPUT
        reject_with: icmp-proto-unreachable
        state: absent
    - name: Create rule
      ansible.builtin.iptables:
        chain: INPUT
        reject_with: icmp-proto-unreachable
  when: iptables_tricking_port_scanners

- name: Reject all remaining incoming traffic with icmp protocol unreachable messages
  ansible.builtin.iptables:
    chain: INPUT
    reject_with: icmp-proto-unreachable
  when: not iptables_tricking_port_scanners

# TCP

- name: Tricking TCP port scanner
  block:
    - name: Remove existing rule if exists
      ansible.builtin.command:
        cmd: "iptables -D TCP -p tcp -m recent --update --rsource --seconds 60 --name TCP-PORTSCAN -j REJECT --reject-with tcp-reset"
      ignore_errors: yes
    - name: Create rule
      ansible.builtin.command:
        cmd: "iptables -I TCP 2 -p tcp -m recent --update --rsource --seconds 60 --name TCP-PORTSCAN -j REJECT --reject-with tcp-reset"
  when: iptables_tricking_port_scanners

- name: Allow SSH
  ansible.builtin.iptables:
    chain: TCP
    protocol: tcp
    destination_port: 22
    jump: ACCEPT

- name: Allow FTP
  ansible.builtin.iptables:
    chain: TCP
    protocol: tcp
    destination_port: 21
    jump: ACCEPT
    comment: FTP
  when: iptables_use_ftp

- name: Allow FTP (Active mode)
  ansible.builtin.iptables:
    chain: TCP
    protocol: tcp
    destination_port: 20
    jump: ACCEPT
    comment: FTP (Active mode)
  when: iptables_use_ftp

- name: Allow kubelet
  block:
    - ansible.builtin.iptables:
        chain: TCP
        protocol: tcp
        destination_port: 6443
        jump: ACCEPT
        in_interface: "{{ ansible_default_ipv4.interface }}"
        source: "{{ neighbor_ips }}"
        comment: kubelet
      when: iptables_use_k3s_server

    - ansible.builtin.iptables:
        chain: TCP
        protocol: tcp
        destination_port: 6443
        jump: ACCEPT
        in_interface: "{{ iptables_wireguard_interface }}"
        source: "{{ ipv4.network }}/{{ ipv4.prefix }}"
        comment: kubelet
      when: iptables_use_k3s_server
      vars:
        ipv4: "{{ hostvars[inventory_hostname]['ansible_' + iptables_wireguard_interface].ipv4 }}"

- name: Allow kubelet metrics
  ansible.builtin.iptables:
    chain: TCP
    protocol: tcp
    destination_port: 10250
    jump: ACCEPT
    in_interface: "{{ ansible_default_ipv4.interface }}"
    source: "{{ neighbor_ips }}"
    comment: kubelet metrics
  when: iptables_use_k3s_server or iptables_use_k3s_agent

- name: Allow k3s embbeded etcd
  ansible.builtin.iptables:
    chain: TCP
    protocol: tcp
    destination_port: 2379:2380
    jump: ACCEPT
    in_interface: "{{ ansible_default_ipv4.interface }}"
    source: "{{ neighbor_ips }}"
  when: iptables_use_k3s_server and iptables_k3s_server_ha_embedded_etcd

- name: Allow k8s cilium health check
  ansible.builtin.iptables:
    chain: TCP
    protocol: tcp
    destination_port: 4240
    jump: ACCEPT
    in_interface: "{{ ansible_default_ipv4.interface }}"
    source: "{{ neighbor_ips }}"
    comment: cilium health check
  when: iptables_k8s_cilium

- name: Allow k8s cilium hubble
  ansible.builtin.iptables:
    chain: TCP
    protocol: tcp
    destination_port: 4244:4245
    jump: ACCEPT
    in_interface: "{{ ansible_default_ipv4.interface }}"
    source: "{{ neighbor_ips }}"
    comment: cilium hubble
  when: iptables_k8s_cilium_hubble

- name: Allow k8s metallb L2 LB
  ansible.builtin.iptables:
    chain: TCP
    protocol: tcp
    destination_port: 7946
    jump: ACCEPT
    in_interface: "{{ ansible_default_ipv4.interface }}"
    source: "{{ neighbor_ips }}"
    comment: metallb L2 LB
  when: iptables_k8s_metallb

# UDP

- name: Tricking UDP port scanner
  block:
    - name: Remove existing rule if exists
      ansible.builtin.command:
        cmd: "iptables -D UDP -p udp -m recent --update --rsource --seconds 60 --name UDP-PORTSCAN -j REJECT --reject-with icmp-port-unreachable"
      ignore_errors: yes
    - name: Create rule
      ansible.builtin.command:
        cmd: "iptables -I UDP 2 -p udp -m recent --update --rsource --seconds 60 --name UDP-PORTSCAN -j REJECT --reject-with icmp-port-unreachable"
  when: iptables_tricking_port_scanners

- name: Allow Multicast DNS (mDNS)
  ansible.builtin.iptables:
    chain: UDP
    protocol: udp
    destination_port: 5353
    jump: ACCEPT
    comment: Multicast DNS (mDNS)
  when: iptables_use_mdns

- name: Allow Link-Local Multicast Name Resolution (LLMNR)
  ansible.builtin.iptables:
    chain: UDP
    protocol: udp
    destination_port: 5355
    jump: ACCEPT
    comment: Link-Local Multicast Name Resolution (LLMNR)
  when: iptables_use_llmnr

- name: Allow Wireguard
  ansible.builtin.iptables:
    chain: UDP
    protocol: udp
    in_interface: "{{ ansible_default_ipv4.interface }}"
    destination_port: "{{ iptables_wireguard_port }}"
    jump: ACCEPT
    comment: Wireguard

- name: Allow VXLAN
  ansible.builtin.iptables:
    chain: UDP
    protocol: udp
    destination_port: 8472
    jump: ACCEPT
    in_interface: "{{ ansible_default_ipv4.interface }}"
    source: "{{ neighbor_ips }}"
    comment: VXLAN
  when: (iptables_use_k3s_server or iptables_use_k3s_agent) and iptables_use_vxlan

- name: Allow k8s metallb L2 LB
  ansible.builtin.iptables:
    chain: UDP
    protocol: udp
    destination_port: 7946
    jump: ACCEPT
    in_interface: "{{ ansible_default_ipv4.interface }}"
    source: "{{ neighbor_ips }}"
    comment: metallb L2 LB
  when: iptables_k8s_metallb

# DROP other INPUT traffic

- name: Drop INPUT chain
  ansible.builtin.iptables:
    chain_management: yes
    chain: INPUT
    policy: DROP


# Save rules to filesystem

- name: Save rules to filesystem
  community.general.iptables_state:
    ip_version: ipv4
    state: saved
    path: /etc/iptables/rules.v4
